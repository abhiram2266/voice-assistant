<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Voice Assistant [Quantum Theme]</title>
    <!-- 1. Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- We are using 2D Canvas, no three.js needed -->

    <style>
        /* 1. NEW: Use Inter font (Google/Gemini style) */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif; /* NEW FONT */
            /* 2. Set a base dark purple/navy background */
            color: #e5e7eb; /* Light text */
            overflow: hidden; /* Hide body scrollbars */
            
            /* NEW: Dark solid color, 2D canvas will be on top */
            background-color: #0a0514; /* Very dark purple */
        }
        
        /* 3. This is the new 2D animation canvas background. */
        #plexus-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.7;
        }

        /* NEW: Preloader styles */
        #preloader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0514; /* Match body background */
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 1;
            transition: opacity 1s ease-out; /* Fade out transition */
        }

        #preloader.fade-out {
            opacity: 0;
        }

        .preloader-text {
            font-family: 'Inter', sans-serif;
            font-size: 2.5rem; /* 40px */
            font-weight: 700;
            color: #fff;
            text-shadow:
                0 0 7px #fff,
                0 0 10px #fff,
                0 0 21px #fff,
                0 0 42px #9B59B6, /* Purple glow */
                0 0 82px #9B59B6,
                0 0 92px #9B59B6,
                0 0 102px #9B59B6,
                0 0 151px #9B59B6;
            animation: flicker 2s infinite alternate; /* Flicker animation */
        }

        @keyframes flicker {
            0%, 18%, 22%, 25%, 53%, 57%, 100% {
                text-shadow:
                    0 0 7px #fff,
                    0 0 10px #fff,
                    0 0 21px #fff,
                    0 0 42px #9B59B6,
                    0 0 82px #9B59B6,
                    0 0 92px #9B59B6,
                    0 0 102px #9B59B6,
                    0 0 151px #9B59B6;
            }
            20%, 24%, 55% {        
                text-shadow: none;
            }
        }
        /* END: Preloader styles */


        /* 4. The main "frosted glass" container style (Dark Mode) */
        .glassmorphism {
            /* Dark, polished obsidian effect */
            background: rgba(10, 5, 20, 0.7); /* Very dark purple */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px); /* For Safari */
            border: 1px solid rgba(155, 89, 182, 0.3); /* Supernova Purple border */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5), 0 0 20px rgba(155, 89, 182, 0.2); /* Purple glow */
            
            /* 5. Add a "fade in" animation on load */
            opacity: 0;
            transform: scale(0.95); /* Add scale for "pop-in" */
            transition: opacity 1s ease-out, transform 1s ease-out; /* Animate both */
        }
        
        /* NEW: Class to trigger the main UI fade-in */
        .glassmorphism.visible {
            opacity: 1;
            transform: scale(1);
        }

        /* 6. Custom scrollbar for chat (Neon) */
        #chat-window::-webkit-scrollbar {
            width: 6px;
        }
        #chat-window::-webkit-scrollbar-track {
            background: transparent;
        }
        #chat-window::-webkit-scrollbar-thumb {
            background: rgba(155, 89, 182, 0.5); /* Supernova Purple */
            border-radius: 3px;
        }
        #chat-window::-webkit-scrollbar-thumb:hover {
            background: rgba(155, 89, 182, 0.8);
        }

        /* Custom placeholder */
        #message-input::placeholder {
            color: rgba(155, 89, 182, 0.4);
            font-family: 'Inter', sans-serif; /* NEW FONT */
        }
        
        /* Input focus ring */
        #message-input:focus {
            --tw-ring-color: #9B59B6;
        }

        /* Pulsing animation for status */
        .pulse-status {
            color: #9B59B6; /* Supernova Purple */
            animation: pulse-neon 1.5s infinite;
        }
        @keyframes pulse-neon {
            0% { opacity: 1; text-shadow: 0 0 5px #9B59B6; }
            50% { opacity: 0.7; text-shadow: 0 0 15px #9B59B6; }
            100% { opacity: 1; text-shadow: 0 0 5px #9B59B6; }
        }

        /* Blinking cursor for typing animation */
        .typing-cursor {
            animation: blink 1s step-end infinite;
            font-weight: bold;
            color: rgba(155, 89, 182, 0.8); /* Purple cursor */
        }
        @keyframes blink {
            from, to { opacity: 1; }
            50% { opacity: 0; }
        }

    </style>
</head>
<body class="h-full flex items-center justify-center p-4">

    <!-- NEW: Preloader HTML -->
    <div id="preloader">
        <h1 class="preloader-text">VOICE ASSISTANT</h1>
    </div>

    <!-- The 2D animation will be created and appended here by the script -->
    <canvas id="plexus-canvas"></canvas>

    <!-- Main Chat Container: Apply glassmorphism here -->
    <div class="glassmorphism w-full max-w-2xl h-full sm:h-[90vh] sm:max-h-[700px] rounded-lg shadow-2xl flex flex-col">
        
        <!-- Header -->
        <div class="text-purple-300 p-4 rounded-t-lg flex justify-between items-center border-b border-purple-500/30">
            <!-- UPDATED: Title changed back -->
            <h1 class="text-xl font-bold" style="text-shadow: 0 0 8px #9B59B6;">VOICE ASSISTANT</h1>
            <!-- Listening/Thinking Status -->
            <div id="status-indicator" class="text-sm font-medium h-5"></div>
        </div>

        <!-- Chat Window -->
        <div id="chat-window" class="flex-1 p-6 overflow-y-auto space-y-4">
            <!-- Initial Bot Message -->
            <div class="flex justify-start">
                <div class="bg-gray-800/80 text-gray-200 p-3 rounded-lg max-w-xs shadow-sm border border-gray-700/50">
                    <p>// Q_STATE:ONLINE. Awaiting query. How can I assist?</p> <!-- NEW PERSONA -->
                </div>
            </div>
            <!-- Chat messages will be dynamically added here -->
        </div>

        <!-- Input Area -->
        <div class="p-4 border-t border-purple-500/30 bg-black/30 rounded-b-lg">
            <form id="chat-form" class="flex items-center space-x-3">
                <input
                    type="text"
                    id="message-input"
                    placeholder="Input query..."
                    class="flex-1 p-3 border border-purple-600/50 rounded-full focus:outline-none focus:ring-2 focus:ring-purple-500 bg-gray-900/80 text-purple-300"
                />
                <button
                    type="submit"
                    title="Send"
                    class="bg-purple-600/70 text-white p-3 rounded-full font-semibold hover:bg-purple-500/70 hover:shadow-lg hover:shadow-purple-500/50 hover:scale-105 focus:outline-none focus:ring-2 focus:ring-purple-400 focus:ring-offset-2 focus:ring-offset-gray-900 transition-all duration-200 transform flex-shrink-0 border border-purple-400/50 backdrop-blur-sm"
                >
                    <!-- UPDATED: "Send" Paper Plane Icon -->
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2 .01 7z"/>
                    </svg>
                </button>
                <button
                    type="button"
                    id="speak-button"
                    title="Speak"
                    class="bg-yellow-600/70 text-white p-3 rounded-full font-semibold hover:bg-yellow-500/70 hover:shadow-lg hover:shadow-yellow-500/50 hover:scale-105 focus:outline-none focus:ring-2 focus:ring-yellow-400 focus:ring-offset-2 focus:ring-offset-gray-900 transition-all duration-200 transform flex-shrink-0 border border-yellow-400/50 backdrop-blur-sm"
                >
                    <!-- Mic Icon, now starlight gold -->
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
                    </svg>
                </button>
            </form>
        </div>
    </div>

    <script>
        // === DOM Elements ===
        const chatWindow = document.getElementById('chat-window');
        const chatForm = document.getElementById('chat-form');
        const messageInput = document.getElementById('message-input');
        const speakButton = document.getElementById('speak-button');
        const statusIndicator = document.getElementById('status-indicator');
        const preloader = document.getElementById('preloader'); // NEW
        const mainContainer = document.querySelector('.glassmorphism'); // NEW

        // === On-Load Animation ===
        document.addEventListener('DOMContentLoaded', () => {
            // Start the background animation immediately
            initStream();

            // Set a timer for the preloader
            setTimeout(() => {
                // 1. Start fading out the preloader
                preloader.classList.add('fade-out');

                // 2. Start fading in the main UI
                mainContainer.classList.add('visible');

                // 3. After the fade-out is complete, hide the preloader
                setTimeout(() => {
                    preloader.style.display = 'none';
                }, 1000); // Must match the preloader's transition duration

            }, 2500); // How long to show the preloader (in ms)
        });

        // === Speech Recognition Setup (Voice-to-Text) ===
        // [cite: 2.1, 2.3]
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;

        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.continuous = false; // Stop after one phrase
            recognition.lang = 'en-US';
            recognition.interimResults = false;

            // Handle speech recognition result
            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                messageInput.value = transcript;
                // Automatically send the message
                handleFormSubmit();
            };

            recognition.onstart = () => {
                setStatus('// RECEIVING_QUERY...');
            };

            recognition.onend = () => {
                setStatus('');
            };

            recognition.onerror = (event) => {
                console.error("Speech recognition error:", event.error);
                setStatus('// ERR:SIGNAL_UNCERTAIN');
            };

            // 'Speak' button click listener
            speakButton.addEventListener('click', () => {
                try {
                    recognition.start();
                } catch (e) {
                    console.error("Could not start recognition:", e);
                    setStatus('// ERR:MIC_OFFLINE');
                }
            });

        } else {
            console.warn("Speech Recognition not supported by this browser.");
            speakButton.disabled = true;
            speakButton.classList.add('opacity-50', 'cursor-not-allowed');
            setStatus('// WARN:NO_SPEECH_API');
        }
        
        // === Speech Synthesis Setup (Text-to-Speech) ===
        // [cite: 3.1, 3.2]

        let preferredVoice = null;
        
        function loadVoices() {
            const voices = window.speechSynthesis.getVoices();
            if (voices.length === 0) return; 

            // Try to find a good voice
            const targetVoiceNames = [
                'Google UK English Male', 
                'Daniel', 
                'Microsoft David - English (United States)',
                'Microsoft Zira - English (UnitedStates)',
                'Google US English'
            ];

            preferredVoice = voices.find(voice => 
                targetVoiceNames.some(name => voice.name.includes(name))
            ) || voices[0]; 

            console.log(`// Selected voice: ${preferredVoice.name}`);
        }

        window.speechSynthesis.onvoiceschanged = loadVoices;
        loadVoices(); 

        function speakText(text) {
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'en-US';
                
                // Celestial voice settings
                if (preferredVoice) {
                    utterance.voice = preferredVoice;
                }
                utterance.pitch = 0.8; // Deeper, calmer
                utterance.rate = 1.0;  // Normal speed
                
                window.speechSynthesis.speak(utterance);
            } else {
                console.warn("Speech Synthesis not supported by this browser.");
            }
        }

        // === AI & Chat Logic ===
        
        // --- IMPORTANT ---
        // Your API key is still here.
        const API_KEY = "AIzaSyDa4bzWLxLlO1Tg_IWS6EeKk0ECo0Wzvsc"; // <-- Key pasted

        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${API_KEY}`;

        // !!--- THIS IS THE "MEMORY" ---!!
        let chatHistory = [
            // Start with the system's first message
            {
                role: "model",
                parts: [{ text: "// Q_STATE:ONLINE. Awaiting query. How can I assist?" }]
            }
        ];

        // System instructions to guide the AI
        const systemInstruction = {
            role: "system",
            parts: [{ text: "You are a helpful AI assistant with a 'quantum' persona. You are precise, logical, and calm. You have a perfect memory. Use the provided chat history to understand the full context. If the user asks 'what is my name?', look back in the history to find it. Keep your answers conversational, concise, and use quantum or data-based metaphors (e.g., 'Query received.', 'Resolving state.', 'Affirmative.', 'That aligns with the data.')." }]
        };

        // Handle form submission (Send button)
        chatForm.addEventListener('submit', (e) => {
            e.preventDefault();
            handleFormSubmit();
        });

        async function handleFormSubmit() {
            const userMessage = messageInput.value.trim();
            if (!userMessage) return;

            // 1. Add user's message to UI
            addMessageToUI(userMessage, 'user');

            // 2. Add user's message to the "memory" (chatHistory array)
            chatHistory.push({
                role: "user",
                parts: [{ text: userMessage }]
            });

            // 3. Clear input and show thinking status
            messageInput.value = '';
            setStatus('// RESOLVING_STATE...');

            // 4. Call the Gemini API
            try {
                const aiResponse = await callGeminiAPI(chatHistory, systemInstruction);
                
                // 5. Add AI's response to UI
                addMessageToUI(aiResponse, 'model');

                // 6. Add AI's response to the "memory"
                chatHistory.push({
                    role: "model",
                    parts: [{ text: aiResponse }]
                });

                // 7. Speak the AI's response (will be typed and spoken)
                speakText(aiResponse);

            } catch (error) {
                console.error("Error calling Gemini API:", error);
                const errorMsg = "// ERR:STATE_COLLAPSED. Please resend query.";
                addMessageToUI(errorMsg, 'model');
                speakText(errorMsg);
            } finally {
                // 8. Clear status
                setStatus('');
            }
        }

        /**
         * Calls the Gemini API with the *entire* conversation history.
         * This is how the AI "remembers".
         */
        async function callGeminiAPI(history, instruction) {
            // Check for placeholder key (just in case)
            if (API_KEY === "PASTE_YOUR_FREE_API_KEY_HERE" || API_KEY === "") {
                const errorMsg = "// ERR:API_KEY_INVALID. Please check configuration file.";
                addMessageToUI(errorMsg, 'model');
                speakText(errorMsg);
                return; // Return early
            }

            const payload = {
                contents: [...history],
                systemInstruction: instruction
            };

            // Implement exponential backoff for retries
            let response;
            let delay = 1000;
            for (let i = 0; i< 5; i++) {
                try {
                    response = await fetch(API_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(payload)
                    });

                    if (response.ok) {
                        const result = await response.json();
                        
                        if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts[0].text) {
                            return result.candidates[0].content.parts[0].text;
                        } else {
                            console.warn("API response was OK but content was missing.", result);
                            return "// RESPONSE_NULL. Unable to process query.";
                        }
                    } else if (response.status === 400) { 
                        console.error("API Error 400:", await response.text());
                        const errorMsg = "// ERR:API_KEY_REJECTED. Please check key validity.";
                        addMessageToUI(errorMsg, 'model');
                        speakText(errorMsg);
                        return; // Stop retrying on a bad key
                    } else if (response.status === 429) {
                        console.warn(`API rate limit hit. Retrying in ${delay}ms...`);
                        await new Promise(res => setTimeout(res, delay));
                        delay *= 2; // Exponential backoff
                    } else {
                        console.error("API Error:", response.status, await response.text());
                        throw new Error(`API failed with status ${response.status}`);
                    }
                } catch (error) {
                    console.error("Fetch error:", error);
                    await new Promise(res => setTimeout(res, delay));
                    delay *= 2;
                }
            }
            throw new Error("API request failed after multiple retries.");
        }

        // === UI Helper Functions ===

        /**
         * Adds a chat bubble to the chat window.
         * @param {string} text The message text.
         * @param {'user' | 'model'} role The sender of the message.
         */
        function addMessageToUI(text, role) {
            const messageDiv = document.createElement('div');
            const bubbleDiv = document.createElement('div');
            
            messageDiv.classList.add('flex');
            // Add a little fade-in animation to new bubbles
            bubbleDiv.classList.add('p-3', 'rounded-lg', 'max-w-md', 'shadow-lg', 'opacity-0', 'animate-fade-in');
            
            // Custom animation for fade-in
            const style = document.createElement('style');
            if (!document.getElementById('fade-in-style')) {
                style.id = 'fade-in-style';
                style.innerHTML = `
                    @keyframes fadeIn {
                        from { opacity: 0; transform: translateY(10px); }
                        to { opacity: 1; transform: translateY(0); }
                    }
                    .animate-fade-in {
                        animation: fadeIn 0.3s ease-out forwards;
                    }
                `;
                document.head.appendChild(style);
            }


            if (role === 'user') {
                // User messages are starlight gold
                messageDiv.classList.add('justify-end');
                bubbleDiv.classList.add('bg-yellow-600/80', 'text-white', 'border', 'border-yellow-400/50');
                bubbleDiv.style.boxShadow = '0 0 10px #FFD700';
                bubbleDiv.textContent = text; // User text appears instantly
                messageDiv.appendChild(bubbleDiv);
                chatWindow.appendChild(messageDiv);
            } else {
                // Model messages are dark gray
                messageDiv.classList.add('justify-start');
                bubbleDiv.classList.add('bg-gray-800/80', 'text-gray-200', 'border', 'border-gray-700/50');
                messageDiv.appendChild(bubbleDiv);
                chatWindow.appendChild(messageDiv);
                // NEW: Trigger typing animation for model
                typeTextAnimation(bubbleDiv, text);
            }

            // Auto-scroll to the bottom
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        /**
         * NEW: Creates the typing animation for the AI
         * @param {HTMLElement} element The bubble element to type into
         * @param {string} text The full text to type
         */
        function typeTextAnimation(element, text) {
            let index = 0;
            element.innerHTML = '<span class="typing-cursor">|</span>'; // Start with just a cursor

            const intervalId = setInterval(() => {
                if (index < text.length) {
                    // Update text content and keep cursor at the end
                    element.innerHTML = text.substring(0, index + 1) + '<span class="typing-cursor">|</span>';
                    index++;
                    chatWindow.scrollTop = chatWindow.scrollHeight; // Scroll as it types
                } else {
                    clearInterval(intervalId);
                    element.textContent = text; // Remove cursor when done
                }
            }, 35); // Typing speed in ms (35ms is a good speed)
        }


        /**
         * Updates the status indicator in the header.
         * @param {string} text The status text (e.g., "Listening...", "Thinking...")
         */
        function setStatus(text) {
            statusIndicator.textContent = text;
            if (text) {
                statusIndicator.classList.add('pulse-status');
            } else {
                statusIndicator.classList.remove('pulse-status');
            }
        }
        
        // === UPDATED: 2D "Data Stream" Animation ===
        let canvas, ctx, linesArray;

        function initStream() {
            try {
                canvas = document.getElementById('plexus-canvas'); // Reuse the same canvas
                ctx = canvas.getContext('2d');
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                linesArray = [];
                const numberOfLines = 200; // Lots of lines
                const colors = ["#9B59B6", "#FFD700", "#FFFFFF"]; // Purple, Gold, and White for highlights

                class Line {
                    constructor() {
                        this.x = Math.random() * canvas.width;
                        this.y = Math.random() * canvas.height;
                        this.length = Math.random() * 20 + 5; // Length of the line
                        this.speed = Math.random() * 3 + 2; // Speed
                        this.color = colors[Math.floor(Math.random() * colors.length)];
                        this.width = Math.random() * 2 + 0.5;
                    }
                    draw() {
                        ctx.strokeStyle = this.color;
                        ctx.lineWidth = this.width;
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        // All lines move horizontally to the right
                        ctx.lineTo(this.x + this.length, this.y); 
                        ctx.stroke();
                    }
                    update() {
                        this.x += this.speed;
                        // Reset when it goes off-screen
                        if (this.x > canvas.width) {
                            this.x = -this.length; // Start just off-screen left
                            this.y = Math.random() * canvas.height; // New vertical position
                            this.speed = Math.random() * 3 + 2;
                            this.length = Math.random() * 20 + 5;
                            this.width = Math.random() * 2 + 0.5;
                            this.color = colors[Math.floor(Math.random() * colors.length)];
                        }
                    }
                }

                function createLines() {
                    for (let i = 0; i < numberOfLines; i++) {
                        linesArray.push(new Line());
                    }
                }

                createLines();
                animateStream();

                window.addEventListener('resize', () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                    linesArray = []; // Recreate lines on resize
                    createLines();
                });

            } catch (e) {
                console.error("Failed to initialize 2D background:", e);
            }
        }

        function animateStream() {
            // Use this to create a "motion blur" or "trails" effect
            ctx.fillStyle = 'rgba(10, 5, 20, 0.1)'; // Dark purple with low opacity
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            for (let i = 0; i < linesArray.length; i++) {
                linesArray[i].draw();
                linesArray[i].update();
            }
            requestAnimationFrame(animateStream);
        }
        
    </script>
</body>
</html>

